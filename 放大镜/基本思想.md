# 放大镜

JS放大镜是一种常见的网页交互效果，它可以使用户在鼠标悬停或移动到某个图片上时，放大并显示该图片的细节部分，从而提高用户的浏览体验。

其原理主要是基于以下两个技术：

1. 鼠标事件监听：首先需要监听鼠标在图片上的移动事件，可以使用 JavaScript 监听 `onmousemove` 事件来实现。

2. CSS `background-position` 属性：通过改变 `background-position` 属性的值来实现图片的放大。在放大镜区域上，放大镜区域的

   左上角被放置在原始图像背景的左上角处，在移动放大镜时，背景位置会相应地进行调整来使图像看起来移动。**可以通过计算鼠标的**

   **坐标在放大镜区域中的相对位置，来设置放大镜区域内的 `background-position` 属性值，从而实现放大和移动效果。**

   注意：

   借助宽高等比例放大的两张图片，结合js中鼠标偏移量、元素偏移量、元素自身宽高等属性完成；左侧遮罩移动`Xpx`,右侧大图移动`X*`倍数px`；其余部分就是用小学数学算一下就OK了。

总的来说，JS放大镜的原理就是通过监听鼠标事件和改变CSS属性，来实现在图片上呈现出局部放大效果的功能。

##  1.大致步骤

1.要实现放大镜效果,我们需要做哪些准备工作?

我们首先需要创建三个盒子,分别对应的是小图片,大图片,遮罩层

**注意：我们是将遮罩层的内容放在大盒子上，大盒子与小盒子的大小是没有什么比例，**

2.页面创建完毕,如何开始操作呢?

**第一：首先，我们获取大盒子、小盒子、遮罩层的Dom元素，**

**第二：我们需要获取鼠标的坐标,遮罩层的坐标，**

利用鼠标的坐标-遮罩层的宽/高的一半，来计算出遮罩层的Dom的top/left，但是这样做有一个弊端。

**注意：在做js放大镜时，使用offsetX后出现**

![img](https://img2022.cnblogs.com/blog/2705783/202207/2705783-20220728150347259-150480476.png)

 

 

 每移动一次蒙版就会出现一次闪烁，就会不断的回到左上角。

## 事件onmousemove(event)事件的event对象

![img](https://img2022.cnblogs.com/blog/2705783/202207/2705783-20220728151228252-415671649.png)

 

 

 

原因：刚开始是以为是onmousemove事件的冒泡导致的。后面是发现是因为offsetX和offsetY的问题：以offsetX为例：

![img](https://img2022.cnblogs.com/blog/2705783/202207/2705783-20220728151658526-1317356480.png)

![img](https://img2022.cnblogs.com/blog/2705783/202207/2705783-20220728152348514-1579965327.png)

 



再移动就会又以大边框为对象，计算大的距离，所以就会出现闪烁。mousemove事件触发的事件源元素在不断切换，当鼠标移动时会移动到div中这时 offset的源元素不再是父级的div而是移动的div 这是offset值是相对于移动的div 所以是较小的值 ，所以会回到左上角。

**主要是offsetX/Y的问题**

注意：offsetX，offsetY 针对目标元素的左上角坐标（e.target）。比如你点击一个按钮，那么offsetX就是按钮左上角跟鼠标点击位置的偏移坐标。而offsetTop是相对于距离最近定位的父元素的位置。

```js
// 简单来说：当我们的鼠标移动到小图片盒子时，这时我们e.offsetX，参考的是到小盒子的距离，
mouseX = e.offsetX;
   mouseY = e.offsetY;
//这时我们利用top/left将遮罩层放在鼠标的小面，当移动之后就会计算的是距离蒙版边框的距离，这时目标元素的为蒙版。这时计算使用offsetX-蒙版的一半就会等于0，就会跳回到原点
      mask.style.top = mouseY - mask.offsetHeight / 2 + "px";
      mask.style.left = mouseX - mask.offsetWidth / 2 + "px";
```

## 解决办法

1. **在蒙版加一个pointer-events: none样式就可以了，这个属性除了指示该元素不是鼠标事件的目标之外，值none表示鼠标事件“穿**

   **透”该元素并且指定该元素“下面”的任何东西。**

2. **不使用offsetX和offsetY。可以使用getBoundingClientRact方法。**

**第三步:判断遮罩层是否超出小盒子的范围,超出则拉回**







第三步:计算大图跟随遮罩层移动的比例
第四步:最关键的一步,就是必须在页面加载完毕后进行计算小图片/遮罩层的比例=大图片/大盒子的比例